/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
}

html {
  font-size: 62.5%;
}

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  padding: 3rem;
  color: #777;
  box-sizing: border-box;
}

/* the height property allow us to define how long will be the defined box, 95vh means it will take 95% of the viewport. In the browser we will see a little blank space (the remain 5%) in the bottom of the page. 

the background-size=cover means the box will fit smoothly in the viewport width
*/

.header {
  height: 95vh;
  background-image: linear-gradient(
      to right,
      rgba(128, 214, 113, 0.8),
      rgba(40, 180, 133, 0.8)
    ),
    url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
}

.header__logo-box {
  position: absolute;
  top: 4rem;
  left: 4rem;
}

.header__logo {
  height: 3.5rem;
}

/* the transform property allows us to center an element. When we have to center a title it is not exactly 50% top 50% left, we need to put the center of the title it self int that 50% of it parent instead of the start of the title, that it is way we need to use transform */

.header__text-box {
  position: absolute;
  top: 40%;
  left: 50%;
  text-align: center;
  transform: translate(-50%, -50%);
}

/* backface-visibility is to fix animation shaky */
.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  margin-bottom: 6rem;
}

/* the display allows us to determine if it is a inline of a block element no matter what html element we put in the markup file 

the letter-spacing allow us to define the space between each letter ina title

with the animation-timing-function property we can determine the animation speed across the time. with ease-out value the animation will be faster in the start of the animation
*/

.heading-primary--main {
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;
  animation-name: moveInLeft;
  animation-duration: 1s;
  animation-timing-function: ease-out;
  /* animation-iteration-count: 3;
  animation-delay: 3s; */
}

.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.75rem;
  animation-name: moveInRight;
  animation-duration: 1s;
  animation-timing-function: ease-out;
}

/* the translation that we made is according to the initial state just the title itself not the 0% state */

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }

  100% {
    opacity: 1;
    transform: translate(0);
  }
}

/* 

the visited pseudo class determine if the user already visit the element, you can style it with some limit because of privacy concerns

the transistion state is defined in the initial state (always), this determine to which property the animation is applied and the duration also

To style links appropriately, put the :visited rule after the :link rule but before the :hover and :active rules, as defined by the LVHA-order: :link — :visited — :hover — :active. */

.btn:link,
.btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  font-size: 1.6rem;
  display: inline-block;
  border-radius: 10rem;
  transition: all 0.2s;
  position: relative;
}

.btn:hover {
  transform: translateY(-3rem);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
}

.btn:active {
  transform: translateY(-1rem);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2);
}

.btn--white {
  background-color: #fff;
  color: #777;
}

/* the after pseudo element allows us to duplicate the original element, we will use this fantastic pseudo element for animation purposes. think it as a copy that you can manipulate 

the z-index property determine which will be the position of the copy, -1 means it will be behind of the original one

position is set to absolute and it position is relative to his parent (original button)
*/

.btn::after {
  content: "";
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 100px;
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all 0.4s;
}

.btn--white::after {
  background-color: #fff;
}

.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0;
}

/* the animation-fill-mode property allow as to use the same propertys of the 0% animation state. We use this to put the bottom invisible until the animation starts */
.btn--animated {
  animation: moveInBottom 0.5s ease-out 0.75s;
  animation-fill-mode: backwards;
}
